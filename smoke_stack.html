<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>smoke stack</title>
<style>
:root {
  --blue: #1e90ff;
  --white: #ffffff;
}
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100vw;
  background-color: #003322;
}
#menu_panel {
  position: absolute;
  left:0vw;
  top:0vh;
  height: 7vh;
  width: 100vw;
  background-color:  var(--blue);
  color: #1EFF00;
  display: flex;
}
#menu_panel button {
  background-color:  var(--blue);
  color: var(--white);
  border: none;
  padding: 10px 31px;
  cursor: pointer;
}
#menu_panel div {
  position absolute;
  background-color:  var(--blue);
  color: var(--white);
  border: solid 1px white;
  left:50%
  height:100%
  width:55%
  margin:10px;
  padding: 10px 210px;
  cursor: pointer;
}
#menu_panel button:hover {
  background-color:  var(--white);
  color: #151515;
}
#left_panel{
  position: absolute;
  left:0vw;
  top:7vh;
  width: 20vw;
  height: 93vh;
  background-color: blue;
}
#palette_panel{
  left:0%;
  top:0%;
  width: 100%;
  height: 33%;
  background-color: #003322;
}
#palette_panel canvas{
  position: absolute;
  left:3%;
  top: 3%;
  width: 94%;
  height: 27%;
  background-color: blue;
}

#left_panel_menu {
  left:0%;
  top:34%;
  width: 100%;
  height: 67%;
  background-color: #003322;
  color: #fff;
}

#left_panel_menu div {
  display: inline-block;
  margin: 2px;
  background-color: var(--blue);
  color: var(--white);
  //border:3px solid white;
  text-align: center;
  vertical-align: middle;
  line-height: 35px;
  width: 47%; /* Make sure the buttons fill the grid cells */
  height: 10%;
}
#left_panel_menu div:hover {
  background-color: var(--white);
  color: black;
}
#current_layer{
  position: absolute;
  left:20vw;
  top:7vh;
  width: 93vh;
  height: 93vh;
  background-color: #000000;
}
#current_layer canvas{
  position: absolute;
  left:1%;
  top: 1%;
  width: 98%;
  height: 98%;
  background-color: #66ff66;
}
#right_panel{
  position: absolute;
  left:80vw;
  top:7vh;
  width: 20vw;
  height: 93vh;
  background-color: blue;
}

#right_panel canvas{
  position: absolute;
  left:1%;
  top: 0%;
  width: 80%;
  height: 80%;
  background-color: #003322;
}

#animateDiv{
  position: absolute;
  left:83%;
  top: 2%;
  width: 15%;
  height: 10%;
  background-color: var(--blue);
  color: var(--white);
  //border:3px solid white;
  text-align: center;
  vertical-align: middle;
  line-height: 50px;
}
#animateDiv:hover {
  background-color: var(--white);
  color: black;
}
#stack{
  position: absolute;
  left:83%;
  top: 14%;
  width: 15%;
  height: 10%;
  background-color: var(--blue);
  color: var(--white);
  //border:3px solid white;
  text-align: center;
  vertical-align: middle;
  line-height: 50px;
}
#stack:hover {
  background-color: var(--white);
  color: black;
}
#stackOffset{
  position: absolute;
  left:83%;
  top: 26%;
  width: 15%;
  height: 10%;
  background-color: var(--blue);
  color: var(--white);
  //border:3px solid white;
  text-align: center;
  vertical-align: middle;
  line-height: 50px;
}
#stackOffset:hover {
  background-color: var(--white);
  color: black;
}

#stackScaleY{
  position: absolute;
  left:83%;
  top: 38%;
  width: 15%;
  height: 10%;
  background-color: var(--blue);
  color: var(--white);
  //border:3px solid white;
  text-align: center;
  vertical-align: middle;
  line-height: 50px;
}
#stackScaleY:hover {
  background-color: var(--white);
  color: black;
}
#stackRot{
  position: absolute;
  left:83%;
  top: 50%;
  width: 15%;
  height: 10%;
  background-color: var(--blue);
  color: var(--white);
  //border:3px solid white;
  text-align: center;
  vertical-align: middle;
  line-height: 50px;
}
#stackRot:hover {
  background-color: var(--white);
  color: black;
}
#makeSheet{
  position: absolute;
  left:83%;
  top: 62%;
  width: 15%;
  height: 10%;
  background-color: var(--blue);
  color: var(--white);
  //border:3px solid white;
  text-align: center;
  vertical-align: middle;
  line-height: 50px;
}
#makeSheet:hover {
  background-color: var(--white);
  color: black;
}
</style>
</head>
<body>
<input type="file" id="fileInput" accept=".json" style="display:none">
<div id='menu_panel'>
<button id="new_stack"onclick='Prectx.clearRect(0, 0, Prectx.canvas.width, Prectx.canvas.height);anim8=false;mode="animate";reset(parseInt(prompt("sprite size?","16")))'>new_stack</button>
<button id="new_palette" onclick="newPalette()">new_palette</button>
<div id="layerInfo">LAYERS 1/1</div>
</div>
<div id='left_panel'>
<div id='palette_panel'>
<canvas id="palette_panel_canvas"></canvas>
</div>
<div id="left_panel_menu">
<div id="hMirror" onclick="if(horMirror){horMirror=false}else{horMirror=true}">H mirror</div>
<div id="vMirror" onclick="if(verMirror){verMirror=false}else{verMirror=true}">V mirror</div>
<div id="pencil"onclick="_pencil=true;line=false;paint=false;mLeft=false">Pencil</div>
<div id="paint"onclick="_pencil=false;pencilSize=1;horMirror=false;verMirror=false;line=false;paint=true;mLeft=false">Paint</div>
<div id="new_layer"onclick="make_layer()">New Layer</div>
<div id="remove_layer"onclick="if(layer>0){remove_layer(layer);layer--}">Remove Layer</div>
<div id="copy_up"onclick="copy_up()">Copy Up</div>
<div id="line"onclick="line=true;_pencil=false;paint=false;horMirror=false;verMirror=false;mLeft=false">Line</div>
<div onclick="upLayer()">UP LAYER</div>
<div onclick="downLayer()">DOWN LAYER</div>
<div onclick="undo()">undo</div>
<div >?</div>
<div onclick="clear_layer(layer)">CLEAR</div>

<div id="pencilPlus"onclick="if(pencilSize>1){pencilSize--}">[1]</div>
<div onclick="load()">LOAD</div>
<div onclick="save()">SAVE</div>
</div>
</div>
<div id='right_panel'>
<canvas id="preview_canvas"></canvas>
<div id="animateDiv" onclick="if(anim8==true){anim8=false}else{anim8=true;animating()}">animate</div>
<div id="stack"onclick="if(stacked==true){stacked=false}else{stacked=true;stack_spin()}">stack</div>
<div id="stackOffset" >Offset</div>
<div id="stackScaleY" >Scale</div>
<div id="stackRot" >Rotate</div>
<div id="makeSheet"onclick="export_sprite_strip()">Export</div>
</div>
<div id='current_layer'>
<canvas id="current_layer_canvas"></canvas>
</div>
<canvas id="offscreen_canvas" style='display:none;'></canvas>

<script>
function blank(sw){
  let temp = []
  for (let y = 0; y < sw; y++) {
    var row = [];
    for (let x = 0; x < sw; x++) {
      row.push('#feeeef');
    }
    temp.push(row);
  };
  return JSON.parse(JSON.stringify(temp))
}
function data_clear(sw){
  data = []
  for (let y = 0; y < sw; y++) {
    var row = [];
    for (let x = 0; x < sw; x++) {
      row.push('#feeeef');
    }
    data.push(row);
  };
}
function reset(sw){
  spriteWidth = sw;
  data= []
  undos = [];
  data_clear(sw)
  color = '#ffffff'
  pencilSizer = false;
  mx = 0;
  my = 0;
  ox=0;
  oy=0;
  cx=0;
  cy=0;
  tick=0
  animSpeed=500;
  anim8 = false;
  stacked=false;
  stackRot=0;
  stackOffsetY=2;
  stackScale=1;
  mode='animate'
  _pencil=true;
  paint=false;
  line=false;
  lineSx=null
  lineSy=null
  lineEx=null
  lineEy=null
  painting=false
  pencilSize=1;
  previewScale = 2
  horMirror = false
  verMirror = false
  cellX = 0;
  cellY = 0;
  lineData = []
  for (let y = 0; y < sw; y++) {
    var row = [];
    for (let x = 0; x < sw; x++) {
      row.push('#feeeef');
    }
    lineData.push(row);
  };
  mLeft=false;
  mRight=false;
  gs=0;
  layers = []
  layerCanvases=[]
  layer=0;
  keys=[];
  keys[88]=false
  keys[89]=false
  make_layer(data)
}
function load(){
  document.getElementById('fileInput').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (file && file.type === 'application/json') {
      const reader = new FileReader();
      reader.onload = function(e) {
        const fileContent = e.target.result;
        project = JSON.parse(fileContent);  // Display as string
        spriteWidth = project.spriteWidth;
        layers = [];
        layers = project.layers;
        layerCanvases = [];
        for(let i = 0; i < layers.length; i ++){
          layerCanvases.push(createOffscreenCanvas(spriteWidth, spriteWidth))
          updateLayerCanvas(i)
        }
        
        layer = 0;
        data = JSON.parse(JSON.stringify(layers[layer]))
        draw_data(data)
      };
      reader.readAsText(file);  // Read the file content as text
    } else {
      alert('Please select a valid JSON file');
    }
  });
  document.getElementById('fileInput').click();
}
function save(){
let project = {}
  project.spriteWidth = spriteWidth;
  project.layers = JSON.parse(JSON.stringify(layers))
  var content = JSON.stringify(project)
const blob = new Blob([content], { type: "text/json" }); // Create a Blob object with the JS content
  const url = URL.createObjectURL(blob); // Create a URL for the Blob
  const link = document.createElement("a");
  link.href = url;
  link.download = "map.json"; // Set the filename
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
reset(16)

layerInfoDiv = document.getElementById("layerInfo");
pencilPlusDiv = document.getElementById("pencilPlus");
hMirrorDiv = document.getElementById("hMirror");
vMirrorDiv = document.getElementById("vMirror");
stackRotDiv = document.getElementById("stackRot");
stackScaleYDiv = document.getElementById("stackScaleY");
stackOffsetDiv = document.getElementById("stackOffset");
stackDiv = document.getElementById("stack");
animateDiv = document.getElementById("animateDiv");
lineDiv = document.getElementById("line");
pencilDiv = document.getElementById("pencil");
paintDiv = document.getElementById("paint");
Ppanel = document.getElementById("palette_panel");
Pcanvas = document.getElementById("palette_panel_canvas");
Pctx = Pcanvas.getContext("2d");
Rpanel = document.getElementById("right_panel");
Prevcanvas = document.getElementById("preview_canvas");
Prectx = Prevcanvas.getContext("2d");
cLay = document.getElementById("current_layer");
Rpanel.style.left = cLay.getBoundingClientRect().right+'px'
Rpanel.style.width = (window.innerWidth-cLay.getBoundingClientRect().right)+'px'
cLcanvas = document.getElementById("current_layer_canvas");
cLctx = cLcanvas.getContext("2d");
cLcanvas.width=cLcanvas.getBoundingClientRect().width
cLcanvas.height=cLcanvas.getBoundingClientRect().height
Prevcanvas.width=Prevcanvas.getBoundingClientRect().width
Prevcanvas.height=Prevcanvas.getBoundingClientRect().height
oFFcanvas = document.getElementById("offscreen_canvas");
oFFctx = oFFcanvas.getContext("2d");
function newPalette(){
  // Create file input
  var fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = 'image/*';
  fileInput.addEventListener('change', function(event) {
    var file = event.target.files[0];
    if (file) {
      // Read the file as base64
      var reader = new FileReader();
      reader.onload = function(readerEvent) {
        // Set the base64 value to the text box
        let b64 = readerEvent.target.result;
        palette.src = b64;
      };
      reader.readAsDataURL(file);
    }
  });
  
  // Trigger the file input click
  fileInput.click();
}
let palette = new Image();
palette.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACACAMAAADTa0c4AAADAFBMVEUAAAAiIDRFKDxmOTGPVjvfcSbZoGbuw5r78jaZ5VBqvjA3lG5LaS9SSyQyPDk/P3QwYIJbbuFjm/9fzeTL2/z///+brbeEfodpampZVlJ2QoqsMjLZV2PXe7qPl0qKbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQfngCAAAAwUlEQVR42uzaoQ0AMAhFQWgquv/EHQH/uWdBXYKja6jD56eWBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANtRvWgifOwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALCg6z/ACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgPj8BzgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ3wcAAP//AwDmDQE3Ixu6CAAAAABJRU5ErkJggg==';
palette.loaded=false;

palette.onload = function () {
  Pctx.drawImage(palette, 0, 0, Pcanvas.width, Pcanvas.height);
setTimeout(function(){main()},100)
};
function animating(){
  if(!anim8||stacked){
    anim8=false
    layer=0;
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    draw_data(data);
    return;
  }
  layer++
  if(mode=='animate'){
  if(layer==layers.length){layer=0}
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    draw_data(data);
  }
  if(mode=='stack'){
    draw_stack()
    
  }
if(anim8){setTimeout(function(){animating()},animSpeed)}
}
function stack_spin(){
  draw_stack()
if(stacked){setTimeout(function(){stack_spin()},300)}
}
function clear_layer(layer){
  layers[layer] = blank(spriteWidth);
  data_2_canvas(Prectx,layers[layer],previewScale)
  data = blank(spriteWidth)
  updateLayerCanvas(layer)
  
}
function upLayer(){
if(layer<layers.length-1){layer++}else{return}
  data_2_canvas(Prectx,layers[layer],previewScale)
  data_clear(spriteWidth)
  data=JSON.parse(JSON.stringify(layers[layer]))
  draw_data(data);
}
function downLayer(){
if(layer>0){layer--}else{return}
  data_2_canvas(Prectx,layers[layer],previewScale)
  data_clear(spriteWidth)
  data=JSON.parse(JSON.stringify(layers[layer]))
  draw_data(data);
}
frameCount = 0; // To track the number of frames
lastTime = performance.now(); // Initial time for the FPS calculation
fps = 0; // Current FPS value
function calculateFPS() {
  const now = performance.now(); // Get the current time
  frameCount++; // Increment the frame count
  if (now - lastTime >= 1000) {
    fps = frameCount; // FPS is the number of frames counted in 1 second
    frameCount = 0; // Reset the frame count
    lastTime = now; // Reset the timer
  }
}
function main(){
  // for random stuff to do
  rect = cLcanvas.getBoundingClientRect();
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
    cLcanvas.style.cursor = "none";
  }else{
    cLcanvas.style.cursor = "default";
  }
  ///////////////////////////////////////////////////////////////////////////////////
  
  
  calculateFPS()
  //document.title='FPS: '+fps
  layerInfoDiv.innerText = 'LAYERS  '+(layer+1)+' / '+layers.length
  pencilPlusDiv.innerText = '['+pencilSize+']'
if(horMirror==true){hMirrorDiv.style.background='blue'}else{hMirrorDiv.style.background='#1e90ff'}
if(verMirror==true){vMirrorDiv.style.background='blue'}else{vMirrorDiv.style.background='#1e90ff'}
if(stacked==true){stackDiv.style.background='blue'}else{stackDiv.style.background='#1e90ff'}
if(anim8==true){animateDiv.style.background='blue'}else{animateDiv.style.background='#1e90ff'}
if(line==true){lineDiv.style.background='blue'}else{lineDiv.style.background='#1e90ff'}
if(_pencil==true){pencilDiv.style.background='blue'}else{pencilDiv.style.background='#1e90ff'}
if(paint==true){paintDiv.style.background='blue'}else{paintDiv.style.background='#1e90ff'}
  
  
  
  document.title = mLeft
  requestAnimationFrame(main);
}
function copy_data(){
  layers[layer]=JSON.parse(JSON.stringify(data))
  updateLayerCanvas(layer)
}
dataRotate = 0
////////////////////////////////////////////////////////////////////
// INPUT HANDLING
////////////////////////////////////////////////////////////////////
document.addEventListener('keydown', function(event) {
  //event.key event.keyCode
  keys[event.keyCode]=true
  //alert(event.keyCode)
  //88 x
  //89 y
  //37 left 38 up 39 right 40 down
  
if(event.key=='Escape'){if(confirm('close smoke_stack????')){window.close()}}
  
  //alert(event.key)
  //alert(event.keyCode)
  //control && z undo function
  if(keys[17]&&keys[90]){
    undo();
    keys[17]=false;
    keys[90]=false;
  }
  
});
document.addEventListener('keyup', function(event) {
  //event.key event.keyCode
  keys[event.keyCode]=false
if(event.key=='p'){pencilSizer=false}
});
addEventListener('mousemove', function(event) {
  // Otherwise use mouse input
  if (event.pageX != undefined && event.pageY != undefined) {
    mx = event.pageX;
    my = event.pageY;
  } else {
    mx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    my = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
  }
  rect = cLcanvas.getBoundingClientRect();
  scaleX = cLcanvas.width / rect.width;  // Scale factor for X
  scaleY = cLcanvas.height / rect.height; // Scale factor for Y
  adjustedX = (mx - rect.left) * scaleX;
  adjustedY = (my - rect.top) * scaleY;
  // snaps into place according to grid overlay
  cx = Math.round(adjustedX/gs)*gs
  cy = Math.round(adjustedY/gs)*gs
  cellX = cx/gs
  cellY = cy/gs
if(cellX<0){cellX=0}
if(cellY<0){cellY=0}
if(cellY>spriteWidth-1){cellY=spriteWidth-1}
  draw_data(data)
});
document.addEventListener('mousedown', function(event) {
  // event.button  0 left 1 middle 2 right
if(event.button==0){mLeft=true}
if(event.button==2){mRight=true}
  
  ////////color picker code
  var rect = Pcanvas.getBoundingClientRect();
  //checks if its over the palette for color picking and left mouse is down
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom&&mLeft){
    var scaleX = Pcanvas.width / rect.width;  // Scale factor for X
    var scaleY = Pcanvas.height / rect.height; // Scale factor for Y
    var adjustedX = (mx - rect.left) * scaleX;
    var adjustedY = (my - rect.top) * scaleY;
    const eyeDropper = getPixelColor(adjustedX, adjustedY);
    color = eyeDropper;
    // document.title=color
    mLeft=false
  }
  draw_data(data)
});
cLcanvas.addEventListener('mouseup', function(event) {
backup();
});
document.addEventListener('mouseup', function(event) {
if(event.button==0){mLeft=false}
if(event.button==2){mRight=false}
  if(line){
    lineEx=-1
  }
  // event.button  0 left 1 middle 2 right
});
window.addEventListener('contextmenu', function(event) {event.preventDefault()});

//stackScaleYDiv = document.getElementById("stackScaleY");
//stackOffsetDiv = document.getElementById("stackOffset");

document.getElementById("pencilPlus").addEventListener('wheel', function(event) {
  let wheel = 0
if(event.deltaY>0){wheel=1}
if(event.deltaY<0){wheel=-1}
  pencilSize+=wheel;
if(pencilSize<1){pencilSize=1}
if(pencilSize>spriteWidth){pencilSize=spriteWidth}
  this.innerText='['+pencilSize+']'
});
stackRotDiv.addEventListener('wheel', function(event) {
  let wheel = 0
if(event.deltaY>0){wheel=1}
if(event.deltaY<0){wheel=-1}
  stackRot+=wheel;
});
stackOffsetDiv.addEventListener('wheel', function(event) {
  let wheel = 0
if(event.deltaY>0){wheel=1}
if(event.deltaY<0){wheel=-1}
  stackOffsetY+=wheel;
});
stackScaleYDiv.addEventListener('wheel', function(event) {
  let wheel = 0
if(event.deltaY>0){wheel=1}
if(event.deltaY<0){wheel=-1}
  stackScale+=wheel*0.1;
});
document.addEventListener('wheel', function(event) {
  //event.deltaY >0 down <0 up
  let wheel = 0
if(event.deltaY>0){wheel=1}
if(event.deltaY<0){wheel=-1}
  
  var rect = Prevcanvas.getBoundingClientRect();
  //checks if its over the preview for scale adjustment
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom&&!stacked){
  if(!keys[72]){previewScale+=wheel}
  if(previewScale<1){previewScale=1}
    if(mode=='animate'){
      data_2_canvas(Prectx,layers[layer],previewScale)
    }
    if(mode=='stack'){
    if(keys[72]){stackOffsetY+=wheel} // h key
      
    }
    
  }
  rect = cLcanvas.getBoundingClientRect();
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
  if(!pencilSizer){layer+=wheel}else{pencilSize+=wheel;if(pencilSize<1){pencilSize=1}}
  if(layer<0){layer=0}
  if(layer>layers.length-1){layer=layers.length-1}
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    draw_data(data);
  }
});
function getPaletteColor(){
  var rect = Pcanvas.getBoundingClientRect();
  //checks if its over the palette for color picking
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
    var scaleX = Pcanvas.width / rect.width;  // Scale factor for X
    var scaleY = Pcanvas.height / rect.height; // Scale factor for Y
    var adjustedX = (mx - rect.left) * scaleX;
    var adjustedY = (my - rect.top) * scaleY;
    const eyeDropper = getPixelColor(adjustedX, adjustedY);
  if(mLeft){color = eyeDropper}
  }
}
function getPixelColor(x, y) {
  const imageData = Pctx.getImageData(x, y, 1, 1);
  const [r, g, b] = imageData.data; // Extract RGB values
  return rgbToHex(r, g, b);
}
function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function drawGrid(ctx,gridSize){
  let wide = ctx.canvas.getBoundingClientRect().width
  let tall = ctx.canvas.getBoundingClientRect().height
  ctx.strokeStyle = "white";ctx.lineWidth = 1;
  ctx.beginPath();
  for(let x = 0; x<=spriteWidth*gridSize; x+=gridSize){
    ctx.moveTo( x, 0);
    ctx.lineTo( x, ctx.canvas.height);
  }
  for(let y = 0; y<=spriteWidth*gridSize; y+=gridSize){
    ctx.moveTo( 0, y);
    ctx.lineTo( spriteWidth*gridSize, y);
  }
  ctx.closePath();
  ctx.stroke();
  
}
function drawCross(ctx,gridSize){
  let wide = ctx.canvas.getBoundingClientRect().width
  let tall = ctx.canvas.getBoundingClientRect().height
  ctx.strokeStyle = "red";ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo( wide/2, 0);
  ctx.lineTo(  wide/2, ctx.canvas.height);
  ctx.moveTo( 0, tall/2);
  ctx.lineTo( ctx.canvas.height, tall/2);
  ctx.closePath();
  ctx.stroke();
  
}
function data_2_canvas(ctx,data,scale){
  var rect = ctx.canvas.getBoundingClientRect();
  let width = rect.width;
  let height = rect.height
  let offX = (width-spriteWidth*scale)/2
  let offY = (height-spriteWidth*scale)
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  for (let y = 0; y < spriteWidth; y++) {
    for (let x = 0; x < spriteWidth; x++) {
      if (data[y][x] !='#feeeef') {
        ctx.fillStyle = data[y][x];
        ctx.fillRect((x*scale)+offX,(y*scale)+offY,scale,scale)
      }
    }
  }
}
function copy_up(){
  if(layer<layers.length-1){// not currently on the topmost layer.
    layers[layer+1] = JSON.parse(JSON.stringify(layers[layer]))
    layer++
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    updateLayerCanvas(layer)
    draw_data(data);
  }else{ // youll have to create a new layer to copy up to.
    make_layer(layers[layer])
    layer++
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    updateLayerCanvas(layer)
    draw_data(data);
    
  }
}
function remove_layer(layer){
  if(layers.length>1){
    layers.splice(layer,1)
  }
}
function paintFill(startX, startY, fillColor) {
  const targetColor = data[startX][startY];
if (targetColor === fillColor) {return;}
  function isValid(x, y) {
    return (
    x >= 0 &&
    x < spriteWidth &&
    y >= 0 &&
    y < spriteWidth &&
    data[x][y] === targetColor
    );
  }
  let stack = [[startX, startY]];
  while (stack.length > 0) {
    const [x, y] = stack.pop();
    let left = x;
    while (isValid(left - 1, y)) left--;
    let right = x;
    while (isValid(right + 1, y)) right++;
    for (let i = left; i <= right; i++) {
      data[i][y] = fillColor;
      if (isValid(i, y - 1)) stack.push([i, y - 1]);
      if (isValid(i, y + 1)) stack.push([i, y + 1]);
    }
  }
  
}
function drawLine(x1, y1, x2, y2, data, color) {
  const dx = Math.abs(x2 - x1);
  const dy = Math.abs(y2 - y1);
  const sx = x1 < x2 ? 1 : -1; // Step direction for x
  const sy = y1 < y2 ? 1 : -1; // Step direction for y
  let err = dx - dy;
  while (true) {
    // Set the pixel color in the data array
    if (x1 >= 0 && x1 < spriteWidth && y1 >= 0 && y1 < spriteWidth) {
      data[y1][x1] = color;
    }
    // If we have reached the end point, break
    if (x1 === x2 && y1 === y2) break;
    const e2 = err * 2;
    if (e2 > -dy) {
      err -= dy;
      x1 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y1 += sy;
    }
  }
}

function pencil(startX, startY, endX, endY, fillColor) {
  rect = cLcanvas.getBoundingClientRect();
if(mx<rect.left||mx>rect.right||my<rect.top||my>rect.bottom){return}
  for(let x = startX;x<endX;x++){
    for(let y = startY;y<endY;y++){
      if(x<spriteWidth&&y<spriteWidth){
        data[y][x] = fillColor;
      }
    }
  }
}
function eraser(startX, startY, endX, endY, fillColor) {
  for(let x = startX;x<endX;x++){
    for(let y = startY;y<endY;y++){
      if(x<spriteWidth&&y<spriteWidth){
        data[y][x] = '#feeeef';
      }
    }
  }
}
function draw_data(_data){
  if(mode=='animate'){
    // clears cLcanvas
    cLctx.clearRect(0, 0, cLcanvas.width, cLcanvas.height);
    //draws layer grid
    gs = cLcanvas.getBoundingClientRect().height/spriteWidth
    drawGrid(cLctx,gs)
    // assigns data colors according to cellX and cellY if left mouse button is down. data[cellY][cellX]=color
    rect = cLcanvas.getBoundingClientRect();
    if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
      if(mLeft){
        
        if(_pencil){
          pencil(cellX, cellY, cellX+pencilSize, cellY+pencilSize, color);
          vMcellY = (spriteWidth-1)-cellY-(pencilSize-1)
          hMcellX = (spriteWidth-1)-cellX-(pencilSize-1)
          if(verMirror&&horMirror){
            pencil(cellX, vMcellY, cellX+pencilSize, vMcellY+pencilSize, color);
            pencil(hMcellX, cellY, hMcellX+pencilSize, cellY+pencilSize, color);
            pencil(hMcellX, vMcellY, hMcellX+pencilSize, vMcellY+pencilSize, color);
          }
          if(verMirror&&!horMirror){
            pencil(cellX, vMcellY, cellX+pencilSize, vMcellY+pencilSize, color);
          }
          if(!verMirror&&horMirror){
            pencil(hMcellX, cellY, hMcellX+pencilSize, cellY+pencilSize, color);
          }
          copy_data();data_2_canvas(Prectx,layers[layer],previewScale);
          
        }else{
          if(paint){
            mLeft=false
            paintFill(cellY, cellX, color);draw_data(data);copy_data();data_2_canvas(Prectx,layers[layer],previewScale);
           
          }
          if(line){ //draw line lineSx
            if(lineSx==null){
              lineSx = cellX;
              lineSy = cellY
            }
            
            if(lineEx==null&&lineSx!=null){
              lineData = blank(spriteWidth)
              drawLine(lineSx, lineSy, cellX, cellY, lineData, '#ff0000')
              
            }
          }
        }
      }else{
        if(line){ //draw line lineSx
          
          if(lineEx==null&&lineSx!=null){
            lineData = blank(spriteWidth)
            drawLine(lineSx, lineSy, cellX, cellY, lineData, '#ff0000')
            
          }else{
            for (let y = 0; y < spriteWidth; y++) {
              for (let x = 0; x < spriteWidth; x++) {
                if (lineData[y][x] !== '#feeeef') {
                  data[y][x]=color
                }
              }
            };
            lineSx=null;
            lineSy=null;
            lineEx=null;
            lineEy=null;
            lineData = blank(spriteWidth)
            copy_data();data_2_canvas(Prectx,layers[layer],previewScale);
           
            
          }
        }
      }
      if(mRight){
        vMcellY = (spriteWidth-1)-cellY-(pencilSize-1)
        hMcellX = (spriteWidth-1)-cellX-(pencilSize-1)
        if(verMirror&&horMirror){
          eraser(cellX, vMcellY, cellX+pencilSize, vMcellY+pencilSize, color);
          eraser(hMcellX, cellY, hMcellX+pencilSize, cellY+pencilSize, color);
          eraser(hMcellX, vMcellY, hMcellX+pencilSize, vMcellY+pencilSize, color);
        }
        if(verMirror&&!horMirror){
          eraser(cellX, vMcellY, cellX+pencilSize, vMcellY+pencilSize, color);
        }
        if(!verMirror&&horMirror){
          eraser(hMcellX, cellY, hMcellX+pencilSize, cellY+pencilSize, color);
        }
        eraser(cellX, cellY, cellX+pencilSize, cellY+pencilSize, color);
        ;copy_data();data_2_canvas(Prectx,layers[layer],previewScale);
      }
    }
    // goes thru and draws current layer data values to cLcanvas.
    for (let y = 0; y < spriteWidth; y++) {
      for (let x = 0; x < spriteWidth; x++) {
        if(layer>0){
          if(layers[layer-1][y][x]!='#feeeef'){
            cLctx.fillStyle = layers[layer-1][y][x];
            cLctx.globalAlpha=0.5
            cLctx.fillRect(x*gs,y*gs,gs,gs)
            cLctx.globalAlpha=1
          }
        }
        if(data[y][x]!='#feeeef'){
          cLctx.fillStyle = data[y][x];
          cLctx.fillRect(x*gs,y*gs,gs,gs)
        }
        if(lineData[y][x]!='#feeeef'){
          cLctx.fillStyle = lineData[y][x];
          cLctx.fillRect(x*gs,y*gs,gs,gs)
        }
      }
    }
    drawCross(cLctx,gs)
    // draws cursor box on cLcanvas
    cLctx.fillStyle = color;
    cLctx. strokeStyle = invertColor(color);
    let tempSize = pencilSize
  if(line||paint){tempSize=1}
    cLctx.fillRect(cx,cy,gs*tempSize,gs*tempSize)
    let md=gs/4
    cLctx.lineWidth = 3;
    cLctx.strokeRect(cx+md,cy+md,gs*tempSize-md*2,gs*tempSize-md*2)
    cLctx.strokeRect(cx,cy,gs*tempSize,gs*tempSize)
    hMcellX = Math.floor(cx/gs) // gets the data[x]
    hMx = ((spriteWidth-1)-(hMcellX+pencilSize-1))*gs
    vMcellY = Math.floor(cy/gs) // gets the data[y]
    vMy = ((spriteWidth-1)-(vMcellY+pencilSize-1))*gs
    if(horMirror&&!verMirror){
      cLctx.fillStyle = color;
      cLctx. strokeStyle = invertColor(color);
      cLctx.fillRect(hMx,cy,gs*pencilSize,gs*pencilSize)
      cLctx.lineWidth = 3;
      cLctx.strokeRect(hMx,cy,gs*pencilSize,gs*pencilSize)
    }
    if(verMirror&&!horMirror){
      cLctx.fillStyle = color;
      cLctx. strokeStyle = invertColor(color);
      cLctx.fillRect(cx,vMy,gs*pencilSize,gs*pencilSize)
      cLctx.lineWidth = 3;
      cLctx.strokeRect(cx,vMy,gs*pencilSize,gs*pencilSize)
    }
    if(verMirror&&horMirror){
      cLctx.fillStyle = color;
      cLctx. strokeStyle = invertColor(color);
      cLctx.fillRect(hMx,cy,gs*pencilSize,gs*pencilSize)
      cLctx.lineWidth = 3;
      cLctx.strokeRect(hMx,cy,gs*pencilSize,gs*pencilSize)
      
      cLctx.fillStyle = color;
      cLctx. strokeStyle = invertColor(color);
      cLctx.fillRect(cx,vMy,gs*pencilSize,gs*pencilSize)
      cLctx.lineWidth = 3;
      cLctx.strokeRect(cx,vMy,gs*pencilSize,gs*pencilSize)
      
      cLctx.fillStyle = color;
      cLctx. strokeStyle = invertColor(color);
      cLctx.fillRect(hMx,vMy,gs*pencilSize,gs*pencilSize)
      cLctx.lineWidth = 3;
      cLctx.strokeRect(hMx,vMy,gs*pencilSize,gs*pencilSize)
      
    }
  }
}


// Draw the stack using pre-rendered canvases
function draw_stack() {
  /*
  stackRot=0;
  stackOffsetY=2;
  stackScale=1;
  */
  const canvasWidth = oFFcanvas.width;
  const canvasHeight = oFFcanvas.height;
  const stackOffset = stackOffsetY; // Vertical offset between layers
  const centerX = canvasWidth / 2;
  const centerY = canvasHeight / 2;
  const rotationAngle = (Math.PI / 180) * stackRot; // Example rotation angle
  
  // Clear the preview canvas
  oFFctx.clearRect(0, 0, canvasWidth, canvasHeight);
  
  layerCanvases.forEach((layerCanvas, index) => {
    const yOffset = index * stackOffset;
    
    // Save the current context state
    oFFctx.save();
    
    // Translate and rotate
    oFFctx.translate(centerX, centerY - yOffset);
    oFFctx.rotate(rotationAngle);
    
    let offX = (layerCanvas.width*stackScale / 2)
    let offY = (layerCanvas.height*stackScale / 2)
    // Draw the pre-rendered canvas
    oFFctx.drawImage(
    layerCanvas,
    -offX,
    -offY,
    layerCanvas.width*stackScale,
    layerCanvas.height*stackScale
    );
    
    // Restore context for the next layer
    oFFctx.restore();
  });
  Prectx.clearRect(0, 0, Prectx.canvas.width, Prectx.canvas.height);
  Prectx.drawImage(oFFctx.canvas, ox, oy, Prectx.canvas.width, Prectx.canvas.height);
}
// Helper function to draw a single layer
function drawLayerToContext(ctx, data) {
  const scale = 10; // Scale for the size of each layer.
  const halfWidth = (spriteWidth * scale) / 2;
  
  for (let y = 0; y < spriteWidth; y++) {
    for (let x = 0; x < spriteWidth; x++) {
      if (data[y][x] !== '#feeeef') { // Skip empty pixels
        ctx.fillStyle = data[y][x];
        ctx.fillRect((x * scale) - halfWidth, (y * scale) - halfWidth, scale, scale);
      }
    }
  }
}

function backup(){
  undos.push(JSON.parse(JSON.stringify(data))); // backs up most recent data change
if(undos.length>200){undos.splice(0,1)}// if 21 backups exist deletes the oldest one
}
function undo(){
  if(undos.length==0){return}
  data=[] // clears data
  data = JSON.parse(JSON.stringify(undos[undos.length-1])) //sets data to latest undos[]
  undos.splice(undos.length-1,1)//removes latest undos[]
  //shows data revision
  draw_data(data);copy_data();data_2_canvas(Prectx,layers[layer],previewScale);
}
function invertColor(hex) {
  if (hex.indexOf('#') === 0) {
    hex = hex.slice(1);
  }
  // convert 3-digit hex to 6-digits.
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  if (hex.length !== 6) {
    throw new Error('Invalid HEX color.');
  }
  // invert color components
  var r = (255 - parseInt(hex.slice(0, 2), 16)).toString(16),
  g = (255 - parseInt(hex.slice(2, 4), 16)).toString(16),
  b = (255 - parseInt(hex.slice(4, 6), 16)).toString(16);
  // pad each with zeros and return
  return '#' + padZero(r) + padZero(g) + padZero(b);
}

function padZero(str, len) {
  len = len || 2;
  var zeros = new Array(len).join('0');
  return (zeros + str).slice(-len);
}
function export_sprite_strip() {
  // Set the export dimensions
  const spriteHeight = spriteWidth; // Height of each layer
  const spriteWidthPixels = spriteWidth; // Width of each layer
  const stripWidth = spriteWidthPixels * layers.length; // Total width of the sprite strip
  
  // Create a temporary canvas for the sprite strip
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = stripWidth;
  exportCanvas.height = spriteHeight;
  const exportCtx = exportCanvas.getContext("2d");
  
  // Clear the export canvas
  exportCtx.clearRect(0, 0, exportCanvas.width, exportCanvas.height);
  
  // Draw each layer side by side on the strip
  layers.forEach((layerData, index) => {
    const xOffset = index * spriteWidthPixels;
    drawLayerToContextStrip(exportCtx, layerData, xOffset);
  });
  
  // Convert the canvas to a data URL
  const imageDataURL = exportCanvas.toDataURL("image/png");
  
  // Trigger a download using a hidden link
  const downloadLink = document.createElement("a");
  downloadLink.href = imageDataURL;
  downloadLink.download = "sprite_strip.png"; // Default file name
  downloadLink.style.display = "none"; // Hide the link from the UI
  document.body.appendChild(downloadLink); // Add to the DOM
  downloadLink.click(); // Trigger the download
  document.body.removeChild(downloadLink); // Clean up
}

// Helper function to draw a single layer on the strip
function drawLayerToContextStrip(ctx, data, xOffset) {
  const scale = 1; // 1:1 scale for pixel-accurate output
  for (let y = 0; y < spriteWidth; y++) {
    for (let x = 0; x < spriteWidth; x++) {
      if (data[y][x] !== '#feeeef') { // Skip empty pixels
        ctx.fillStyle = data[y][x];
        ctx.fillRect((x * scale) + xOffset, y * scale, scale, scale);
      }
    }
  }
}

function make_layer(data){
  if(data!=null){
    layers.push(JSON.parse(JSON.stringify(data)))
  }else{
    layers.push(blank(spriteWidth))
  }
  layerCanvases.push(createOffscreenCanvas(spriteWidth, spriteWidth))
}

// Create an offscreen canvas for a layer
function createOffscreenCanvas(width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
// Update a specific layer's offscreen canvas when edited
function updateLayerCanvas(layerIndex) {
  const layerCanvas = layerCanvases[layerIndex];
  const ctx = layerCanvas.getContext("2d");
  ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
  
  // Draw the layer data onto its canvas
  drawLayerToContextStrip(ctx, layers[layerIndex], 0);
}

</script>
</body>
</html>
