<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>smoke stack</title>
<style>
:root {
  --blue: #1e90ff;
  --white: #ffffff;
}
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100vw;
  background-color: #f0f0f0;
}
#menu_panel {
  position: absolute;
  left:0vw;
  top:0vh;
  height: 7vh;
  width: 100vw;
  background-color:  var(--blue);
  color: #1EFF00;
  display: flex;
}
#menu_panel button {
  background-color:  var(--blue);
  color: var(--white);
  border: none;
  padding: 10px 15px;
  cursor: pointer;
}
#menu_panel button:hover {
  background-color:  var(--white);
  color: #151515;
}
#left_panel{
  position: absolute;
  left:0vw;
  top:7vh;
  width: 20vw;
  height: 93vh;
  background-color: blue;
}
#palette_panel{
  left:0%;
  top:0%;
  width: 100%;
  height: 25%;
  background-color: orange;
}
#palette_panel canvas{
  position: absolute;
  left:1%;
  top: 1%;
  width: 98%;
  height: 23%;
  background-color: purple;
}
#current_layer{
  position: absolute;
  left:20vw;
  top:7vh;
  width: 93vh;
  height: 93vh;
  background-color: #000000;
}
#current_layer canvas{
  position: absolute;
  left:1%;
  top: 1%;
  width: 98%;
  height: 98%;
  background-color: #66ff66;
}
#right_panel{
  position: absolute;
  left:80vw;
  top:7vh;
  width: 20vw;
  height: 93vh;
  background-color: purple;
}
#layer_display{
  position: absolute;
  left:1%;
  top: 1%;
  width: 98%;
  height: 7%;
  font-size: 24px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #ff3322;
}
#layer_control{
  position: absolute;
  left:1%;
  top: 8%;
  width: 98%;
  height: 7%;
  font-size: 24px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #ff33ff;
}
#right_panel canvas{
  position: absolute;
  left:5%;
  top: 18%;
  width: 80%;
  height: 80%;
  background-color: #003322;
}


</style>
</head>
<body>
<div id='menu_panel'>
<button id="new_stack"onclick='reset(parseInt(prompt("sprite size?")))'>new_stack</button>
<button id="new_palette">new_palette</button>
<button id="mode" onclick='if(mode=="stack"){mode="animate";layer=0;this.innerText="animate"}else{mode="stack";this.innerText="stack"};mLeft=false;'>animate!</button>
</div>
<div id='left_panel'>
<div id='palette_panel'>
<canvas id="palette_panel_canvas"></canvas>
</div>
</div>
<div id='right_panel'>
<div id='layer_display'>1 LAYER</div>
<div id='layer_control'>LAYER_0</div>
<canvas id="preview_canvas"></canvas>
</div>
<div id='current_layer'>
<canvas id="current_layer_canvas"></canvas>
</div>
<canvas id="offscreen_canvas" style='display:none;'></canvas>
<script>

function blank(sw){
  let temp = []
  for (let y = 0; y < sw; y++) {
    var row = [];
    for (let x = 0; x < sw; x++) {
      row.push('#feeeef');
    }
    temp.push(row);
  };
  return JSON.parse(JSON.stringify(temp))
}
function data_clear(sw){
  data = []
  for (let y = 0; y < sw; y++) {
    var row = [];
    for (let x = 0; x < sw; x++) {
      row.push('#feeeef');
    }
    data.push(row);
  };
}
function reset(sw){
  spriteWidth = sw;
  data_clear(spriteWidth)
  color = '#ffffff'
  mx = 0;
  my = 0;
  cx=0;
  cy=0;
  previewScale = 2
  cellX = 0;
  cellY = 0;
  mLeft=false;
  mRight=false;
  gs=0;
  layers = []
  layerCanvases=[]
  layer=0;
  keys=[];
  make_layer(data)
}
reset(12)
cLayer = document.getElementById("layer_control");
lDisplay = document.getElementById("layer_display");
lDisplay.innerText='hello world'
Ppanel = document.getElementById("palette_panel");
Pcanvas = document.getElementById("palette_panel_canvas");
Pctx = Pcanvas.getContext("2d");
Rpanel = document.getElementById("right_panel");
Prevcanvas = document.getElementById("preview_canvas");
Prectx = Prevcanvas.getContext("2d");
cLay = document.getElementById("current_layer");
Rpanel.style.left = cLay.getBoundingClientRect().right+'px'
Rpanel.style.width = (window.innerWidth-cLay.getBoundingClientRect().right)+'px'
cLcanvas = document.getElementById("current_layer_canvas");
cLctx = cLcanvas.getContext("2d");
cLcanvas.width=cLcanvas.getBoundingClientRect().width
cLcanvas.height=cLcanvas.getBoundingClientRect().height
Prevcanvas.width=Prevcanvas.getBoundingClientRect().width
Prevcanvas.height=Prevcanvas.getBoundingClientRect().height
oFFcanvas = document.getElementById("offscreen_canvas");
oFFctx = oFFcanvas.getContext("2d");

let palette = new Image();
palette.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACACAMAAADTa0c4AAADAFBMVEUAAAAiIDRFKDxmOTGPVjvfcSbZoGbuw5r78jaZ5VBqvjA3lG5LaS9SSyQyPDk/P3QwYIJbbuFjm/9fzeTL2/z///+brbeEfodpampZVlJ2QoqsMjLZV2PXe7qPl0qKbzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQfngCAAAAwUlEQVR42uzaoQ0AMAhFQWgquv/EHQH/uWdBXYKja6jD56eWBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANtRvWgifOwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALCg6z/ACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgPj8BzgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ3wcAAP//AwDmDQE3Ixu6CAAAAABJRU5ErkJggg==';
palette.loaded=false;
tick=0
animSpeed=500
stackOffset = 10
anim8 = false;
mode='animate'
palette.onload = function () {
  Pctx.drawImage(palette, 0, 0, Pcanvas.width, Pcanvas.height);
setTimeout(function(){main()},100)
};
function animate(){
  layer++
  
  if(mode=='animate'){
  if(layer==layers.length){layer=0}
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    draw_data(data);
  }
  if(mode=='stack'){
    draw_stack(layer,stackOffset)
    
  }
  var speed = animSpeed
if(mode=='stack'){speed=animSpeed*0.01}
if(anim8){setTimeout(function(){animate()},speed)}
}
frameCount = 0; // To track the number of frames
lastTime = performance.now(); // Initial time for the FPS calculation
fps = 0; // Current FPS value
function calculateFPS() {
  const now = performance.now(); // Get the current time
  frameCount++; // Increment the frame count
  if (now - lastTime >= 1000) {
    fps = frameCount; // FPS is the number of frames counted in 1 second
    frameCount = 0; // Reset the frame count
    lastTime = now; // Reset the timer
  }
}
function main(){
  // for random stuff to do
  if(layers.length>1){
    lDisplay.innerText=layers.length+' layers'
  }else{
    lDisplay.innerText=layers.length+' layer'
  }
  cLayer.innerText='layer '+layer;
  if(keys[16]&&keys[61]){
    keys[16]=false;
    keys[51]=false;
    if(confirm('make new layer?')){
      make_layer()
    }
  }
  rect = cLcanvas.getBoundingClientRect();
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
    cLcanvas.style.cursor = "none";
  }else{
    cLcanvas.style.cursor = "default";
  }
  ///////////////////////////////////////////////////////////////////////////////////
  rect = cLayer.getBoundingClientRect();
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
    if(mLeft&&layers.length>1){
      layer++
    if(layer==layers.length){layer=0}
      data_2_canvas(Prectx,layers[layer],previewScale)
      data_clear(spriteWidth)
      data=JSON.parse(JSON.stringify(layers[layer]))
      draw_data(data);
    }
    mLeft=false;
  }
  
  rect = lDisplay.getBoundingClientRect();
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
    if(mLeft){
      if(confirm('make new layer?')){
        make_layer()
      }
      mLeft=false;
    }
  }
  calculateFPS()
  document.title='FPS: '+fps
  requestAnimationFrame(main);
}
function copy_data(){
  layers[layer]=JSON.parse(JSON.stringify(data))
  updateLayerCanvas(layer)
}
////////////////////////////////////////////////////////////////////
// INPUT HANDLING
////////////////////////////////////////////////////////////////////
document.addEventListener('keydown', function(event) {
  //event.key event.keyCode
if(event.key=='Escape'){window.close()}
if(event.key=='p'){paintFill(cellY, cellX, color);draw_data(data);copy_data();data_2_canvas(Prectx,layers[layer],previewScale);event.key=null}
  if(event.key=='ArrowUp'&&layers.length>1){
    
    layer++
  if(layer==layers.length){layer=0}
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    draw_data(data);
  }
  keys[event.keyCode]=true
if(event.key=='e'){if(confirm('export sprite strip?')){export_sprite_strip()}}
if(event.key=='u'){copy_up()}
if(event.key=='o'){if(oFFcanvas.style.display=='none'){oFFcanvas.style.display='block'}else{oFFcanvas.style.display='none'}}
if(event.key=='a'){if(anim8){anim8=false}else{anim8=true;animate()}}
if(event.key=='m') {if(mode=="stack"){mode="animate";layer=0;this.innerText="animate"}else{mode="stack";this.innerText="stack"};mLeft=false;}
  //alert(event.key)
  //alert(event.keyCode)
});
document.addEventListener('keyup', function(event) {
  //event.key event.keyCode
  keys[event.keyCode]=false
});
addEventListener('mousemove', function(event) {
  // Otherwise use mouse input
  if (event.pageX != undefined && event.pageY != undefined) {
    mx = event.pageX;
    my = event.pageY;
  } else {
    mx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    my = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
  }
  rect = cLcanvas.getBoundingClientRect();
  scaleX = cLcanvas.width / rect.width;  // Scale factor for X
  scaleY = cLcanvas.height / rect.height; // Scale factor for Y
  adjustedX = (mx - rect.left) * scaleX;
  adjustedY = (my - rect.top) * scaleY;
  // snaps into place according to grid overlay
  cx = Math.round(adjustedX/gs)*gs
  cy = Math.round(adjustedY/gs)*gs
  cellX = cx/gs
  cellY = cy/gs
if(cellX<0){cellX=0}
if(cellY<0){cellY=0}
if(cellY>spriteWidth-1){cellY=spriteWidth-1}
  draw_data(data)
});
document.addEventListener('mousedown', function(event) {
  // event.button  0 left 1 middle 2 right
if(event.button==0){mLeft=true}
if(event.button==2){mRight=true}
  
  ////////color picker code
  var rect = Pcanvas.getBoundingClientRect();
  //checks if its over the palette for color picking and left mouse is down
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom&&mLeft){
    var scaleX = Pcanvas.width / rect.width;  // Scale factor for X
    var scaleY = Pcanvas.height / rect.height; // Scale factor for Y
    var adjustedX = (mx - rect.left) * scaleX;
    var adjustedY = (my - rect.top) * scaleY;
    const eyeDropper = getPixelColor(adjustedX, adjustedY);
    color = eyeDropper;
    // document.title=color
    mLeft=false
  }
  draw_data(data)
});
document.addEventListener('mouseup', function(event) {
if(event.button==0){mLeft=false}
if(event.button==2){mRight=false}
  // event.button  0 left 1 middle 2 right
});
window.addEventListener('contextmenu', function(event) {event.preventDefault()});
document.addEventListener('wheel', function(event) {
  //event.deltaY >0 down <0 up
  let wheel = 0
if(event.deltaY>0){wheel=1}
if(event.deltaY<0){wheel=-1}
  
  var rect = Prevcanvas.getBoundingClientRect();
  //checks if its over the preview for scale adjustment
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
  if(!keys[89]){previewScale+=wheel}
  if(previewScale<1){previewScale=1}
    if(mode=='animate'){
      data_2_canvas(Prectx,layers[layer],previewScale)
    }
    if(mode=='stack'){
    if(keys[89]){stackOffset+=wheel} // y key
      
    }
    
  }
  rect = cLcanvas.getBoundingClientRect();
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
    layer+=wheel
  if(layer<0){layer=0}
  if(layer>layers.length-1){layer=layers.length-1}
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    draw_data(data);
  }
});
function getPaletteColor(){
  var rect = Pcanvas.getBoundingClientRect();
  //checks if its over the palette for color picking
  if(mx>rect.left&&mx<rect.right&&my>rect.top&&my<rect.bottom){
    var scaleX = Pcanvas.width / rect.width;  // Scale factor for X
    var scaleY = Pcanvas.height / rect.height; // Scale factor for Y
    var adjustedX = (mx - rect.left) * scaleX;
    var adjustedY = (my - rect.top) * scaleY;
    const eyeDropper = getPixelColor(adjustedX, adjustedY);
  if(mLeft){color = eyeDropper}
  }
}
function getPixelColor(x, y) {
  const imageData = Pctx.getImageData(x, y, 1, 1);
  const [r, g, b] = imageData.data; // Extract RGB values
  return rgbToHex(r, g, b);
}
function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function drawGrid(ctx,gridSize){
  let wide = ctx.canvas.getBoundingClientRect().width
  let tall = ctx.canvas.getBoundingClientRect().height
  ctx.strokeStyle = "white";ctx.lineWidth = 1;
  ctx.beginPath();
  for(let x = 0; x<=spriteWidth*gridSize; x+=gridSize){
    
    ctx.moveTo( x, 0);
    ctx.lineTo( x, ctx.canvas.height);
  }
  for(let y = 0; y<=spriteWidth*gridSize; y+=gridSize){
    ctx.moveTo( 0, y);
    ctx.lineTo( spriteWidth*gridSize, y);
  }
  ctx.closePath();
  ctx.stroke();
  
}
function data_2_canvas(ctx,data,scale){
  var rect = ctx.canvas.getBoundingClientRect();
  let width = rect.width;
  let height = rect.height
  let offX = (width-spriteWidth*scale)/2
  let offY = (height-spriteWidth*scale)
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  for (let y = 0; y < spriteWidth; y++) {
    for (let x = 0; x < spriteWidth; x++) {
      if (data[y][x] !='#feeeef') {
        ctx.fillStyle = data[y][x];
        ctx.fillRect((x*scale)+offX,(y*scale)+offY,scale,scale)
      }
    }
  }
}
function copy_up(){
  if(layer<layers.length-1){// not currently on the topmost layer.
    layers[layer+1] = JSON.parse(JSON.stringify(layers[layer]))
    layer++
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    updateLayerCanvas(layer)
    draw_data(data);
  }else{ // youll have to create a new layer to copy up to.
    make_layer(layers[layer])
    layer++
    data_2_canvas(Prectx,layers[layer],previewScale)
    data_clear(spriteWidth)
    data=JSON.parse(JSON.stringify(layers[layer]))
    updateLayerCanvas(layer)
    draw_data(data);
    
  }
}
function paintFill(startX, startY, fillColor) {
  const targetColor = data[startX][startY];
if (targetColor === fillColor) {return;}
  function isValid(x, y) {
    return (
    x >= 0 &&
    x < spriteWidth &&
    y >= 0 &&
    y < spriteWidth &&
    data[x][y] === targetColor
    );
  }
  let stack = [[startX, startY]];
  while (stack.length > 0) {
    const [x, y] = stack.pop();
    let left = x;
    while (isValid(left - 1, y)) left--;
    let right = x;
    while (isValid(right + 1, y)) right++;
    for (let i = left; i <= right; i++) {
      data[i][y] = fillColor;
      if (isValid(i, y - 1)) stack.push([i, y - 1]);
      if (isValid(i, y + 1)) stack.push([i, y + 1]);
    }
  }
}
function draw_data(_data){
  if(mode=='animate'){
    // clears cLcanvas
    cLctx.clearRect(0, 0, cLcanvas.width, cLcanvas.height);
    //draws layer grid
    gs = cLcanvas.getBoundingClientRect().height/spriteWidth
    drawGrid(cLctx,gs)
    // assigns data colors according to cellX and cellY if left mouse button is down.
  if(mLeft){data[cellY][cellX]=color;copy_data();data_2_canvas(Prectx,layers[layer],previewScale)}
  if(mRight){data[cellY][cellX]='#feeeef';copy_data();data_2_canvas(Prectx,layers[layer],previewScale)}
    // goes thru and draws current layer data values to cLcanvas.
    for (let y = 0; y < spriteWidth; y++) {
      for (let x = 0; x < spriteWidth; x++) {
        if(layer>0){
          if(layers[layer-1][y][x]!='#feeeef'){
            cLctx.fillStyle = layers[layer-1][y][x];
            cLctx.globalAlpha=0.5
            cLctx.fillRect(x*gs,y*gs,gs,gs)
            cLctx.globalAlpha=1
          }
        }
        if(data[y][x]!='#feeeef'){
          cLctx.fillStyle = data[y][x];
          cLctx.fillRect(x*gs,y*gs,gs,gs)
        }
      }
    }
    // draws cursor box on cLcanvas
    cLctx.fillStyle = color;
    cLctx. strokeStyle = invertColor(color);
    cLctx.fillRect(cx,cy,gs,gs)
    cLctx.lineWidth = 3;
    cLctx.strokeRect(cx,cy,gs,gs)
  }
}


// Draw the stack using pre-rendered canvases
function draw_stack(rot,yoffset) {
  const canvasWidth = oFFcanvas.width;
  const canvasHeight = oFFcanvas.height;
  const stackOffset = yoffset; // Vertical offset between layers
  const centerX = canvasWidth / 2;
  const centerY = canvasHeight / 2;
  const rotationAngle = (Math.PI / 180) * rot; // Example rotation angle
  
  // Clear the preview canvas
  oFFctx.clearRect(0, 0, canvasWidth, canvasHeight);
  
  layerCanvases.forEach((layerCanvas, index) => {
    const yOffset = index * stackOffset;
    
    // Save the current context state
    oFFctx.save();
    
    // Translate and rotate
    oFFctx.translate(centerX, centerY - yOffset);
    oFFctx.rotate(rotationAngle);
    
    let ox = layerCanvas.width*previewScale / 2;
    let oy = layerCanvas.height*previewScale / 2
    // Draw the pre-rendered canvas
    oFFctx.drawImage(
    layerCanvas,
    -ox,
    -oy,
    layerCanvas.width*previewScale,
    layerCanvas.height*previewScale
    );
    
    // Restore context for the next layer
    oFFctx.restore();
  });
  Prectx.clearRect(0, 0, Prectx.canvas.width, Prectx.canvas.height);
  Prectx.drawImage(oFFctx.canvas, 0, 0, Prectx.canvas.width, Prectx.canvas.height);
}
// Helper function to draw a single layer
function drawLayerToContext(ctx, data) {
  const scale = 10; // Scale for the size of each layer.
  const halfWidth = (spriteWidth * scale) / 2;
  
  for (let y = 0; y < spriteWidth; y++) {
    for (let x = 0; x < spriteWidth; x++) {
      if (data[y][x] !== '#feeeef') { // Skip empty pixels
        ctx.fillStyle = data[y][x];
        ctx.fillRect((x * scale) - halfWidth, (y * scale) - halfWidth, scale, scale);
      }
    }
  }
}


function invertColor(hex) {
  if (hex.indexOf('#') === 0) {
    hex = hex.slice(1);
  }
  // convert 3-digit hex to 6-digits.
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  if (hex.length !== 6) {
    throw new Error('Invalid HEX color.');
  }
  // invert color components
  var r = (255 - parseInt(hex.slice(0, 2), 16)).toString(16),
  g = (255 - parseInt(hex.slice(2, 4), 16)).toString(16),
  b = (255 - parseInt(hex.slice(4, 6), 16)).toString(16);
  // pad each with zeros and return
  return '#' + padZero(r) + padZero(g) + padZero(b);
}

function padZero(str, len) {
  len = len || 2;
  var zeros = new Array(len).join('0');
  return (zeros + str).slice(-len);
}
function export_sprite_strip() {
  // Set the export dimensions
  const spriteHeight = spriteWidth; // Height of each layer
  const spriteWidthPixels = spriteWidth; // Width of each layer
  const stripWidth = spriteWidthPixels * layers.length; // Total width of the sprite strip
  
  // Create a temporary canvas for the sprite strip
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = stripWidth;
  exportCanvas.height = spriteHeight;
  const exportCtx = exportCanvas.getContext("2d");
  
  // Clear the export canvas
  exportCtx.clearRect(0, 0, exportCanvas.width, exportCanvas.height);
  
  // Draw each layer side by side on the strip
  layers.forEach((layerData, index) => {
    const xOffset = index * spriteWidthPixels;
    drawLayerToContextStrip(exportCtx, layerData, xOffset);
  });
  
  // Convert the canvas to a data URL
  const imageDataURL = exportCanvas.toDataURL("image/png");
  
  // Trigger a download using a hidden link
  const downloadLink = document.createElement("a");
  downloadLink.href = imageDataURL;
  downloadLink.download = "sprite_strip.png"; // Default file name
  downloadLink.style.display = "none"; // Hide the link from the UI
  document.body.appendChild(downloadLink); // Add to the DOM
  downloadLink.click(); // Trigger the download
  document.body.removeChild(downloadLink); // Clean up
}

// Helper function to draw a single layer on the strip
function drawLayerToContextStrip(ctx, data, xOffset) {
  const scale = 1; // 1:1 scale for pixel-accurate output
  for (let y = 0; y < spriteWidth; y++) {
    for (let x = 0; x < spriteWidth; x++) {
      if (data[y][x] !== '#feeeef') { // Skip empty pixels
        ctx.fillStyle = data[y][x];
        ctx.fillRect((x * scale) + xOffset, y * scale, scale, scale);
      }
    }
  }
}

function make_layer(data){
  if(data!=null){
    layers.push(JSON.parse(JSON.stringify(data)))
  }else{
    layers.push(blank(spriteWidth))
  }
  layerCanvases.push(createOffscreenCanvas(spriteWidth, spriteWidth))
}

// Create an offscreen canvas for a layer
function createOffscreenCanvas(width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
// Update a specific layer's offscreen canvas when edited
function updateLayerCanvas(layerIndex) {
  const layerCanvas = layerCanvases[layerIndex];
  const ctx = layerCanvas.getContext("2d");
  ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
  
  // Draw the layer data onto its canvas
  drawLayerToContextStrip(ctx, layers[layerIndex], 0);
}

</script>
</body>
</html>
